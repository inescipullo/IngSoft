\documentclass{article}
\usepackage[utf8]{inputenc} %codificacion de caracteres que permite tildes
\usepackage{amsfonts}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs} % Cursive font
\usepackage{fancyhdr}
\usepackage{framed}
\usepackage{xspace}
\usepackage{dirtree}
\usepackage{multicol}
\usepackage{z-eves}

\usepackage[T1]{fontenc} % fastest font


\usepackage{float}
\usepackage{graphicx}
\usepackage{subcaption}

\newcommand{\desig}[2]{\item #1 $\approx #2$}
\newenvironment{designations}
  {\begin{leftbar}
    \begin{list}{}{\setlength{\labelsep}{0cm}
                   \setlength{\labelwidth}{0cm}
                   \setlength{\listparindent}{0cm}
                   \setlength{\rightmargin}{\leftmargin}}}
  {\end{list}\end{leftbar}}

\newcommand{\setlog}{\{\textit{log}\}\xspace}


\usepackage{mathtools}
\usepackage{xparse} \DeclarePairedDelimiterX{\Iintv}[1]{\llbracket}{\rrbracket}{\iintvargs{#1}}
\NewDocumentCommand{\iintvargs}{>{\SplitArgument{1}{,}}m}
{\iintvargsaux#1}
\NewDocumentCommand{\iintvargsaux}{mm} {#1\mkern1.5mu,\mkern1.5mu#2}

\makeatletter
\newcommand*{\currentname}{\@currentlabelname}
\makeatother



\addtolength{\textwidth}{0.2cm}
\setlength{\parskip}{8pt}
\setlength{\parindent}{0.5cm}
\linespread{1.5}

\pagestyle{fancy}
\fancyhf{}
\rhead{Cipullo}
\lhead{TP Verificación de Software}
\rfoot{\vspace{1cm} \thepage}

\renewcommand*\contentsname{\LARGE Índice}

\setlength{\skip\footins}{0.5cm}


\begin{document}

\begin{titlepage}
    \hspace{-3.2cm}\includegraphics[scale= 0.48]{header.png}
    \begin{center}
        \vfill
            \noindent\textbf{\Huge Ingeniería de Software}\par
            \vspace{.5cm}
            \noindent\textbf{\Huge Trabajo Práctico Verificación de Software}\par
            \vspace{.5cm}
        \vfill
        % \noindent \textbf{\huge Alumnas:}\par
        \vspace{.5cm}
        \noindent \textbf{\Large Cipullo, Inés}\par
 
        \vfill
        % \large Universidad Nacional de Rosario \par
        \noindent\large 2025
    \end{center}
\end{titlepage}
\ 

\section{Requerimientos}

Se describen los requerimientos de un planificador de procesos a corto plazo, encargado de planificar los procesos que están listos para ejecución, también llamado \textit{dispatcher}. Este planificador implementará el algoritmo de planificaión ``Ronda'' (\textit{Round Robin} en inglés), y este sistema tendrá un único procesador.

Un proceso puede estar en alguno de los siguientes estados: \textit{nuevo}, \textit{listo}, \textit{ejecutando}, \textit{bloqueado}, \textit{terminado}. El dispatcher decide entre los procesos que están listos para ejecutarse y determina a cuál de ellos \textit{activar}, y detiene a aquellos que \textit{exceden su tiempo} de procesador, es decir, se encarga de las transiciones entre los estados \textbf{listo} y \textbf{ejecutando}. 

Siguiendo Round Robin, los procesos listos se almacenan en forma de cola, cada proceso listo se ejecuta por un sólo \textit{quantum} y si un proceso no ha terminado de ejecutarse al final de su período, será interrumpido y puesto al final de la cola de procesos listos.
Se deben tener en cuenta, también, aquellas transiciones que involucran otros estados de procesos pero inciden sobre alguno de los dos estados que se controlan desde el dispatcher. Los procesos que sean agregados a la cola de listos por estas otras transiciones, se ubicarán al final de la misma.


\section{Especificación}
Para empezar, se dan las siguientes designaciones.

\begin{designations}
\desig{$p$ es un proceso}{p \in PROCESS}
\desig{$t$ es un contador de ticks del sistema}{t \in TICK}
\desig{proceso nulo}{nullp}
\desig{cantidad de tiempo durante el cual un proceso tiene permiso para ejecutarse en el procesador antes de ser interrumpido}{quantum}
\desig{procesos en estado listo (para ser ejecutados)}{procQueue}
\desig{proceso en ejecución}{current}
\desig{contador de ticks restantes de ejecución que le corresponden a $current$}{remTicks}
\end{designations}

Luego, se introducen los tipos que se utilizan en la especificaci\'on. 

\begin{zed}
    [PROCESS]
\also
    TICK == \nat
\end{zed}

Adem\'as, se presentan las siguientes definiciones axiom\'aticas, donde se define la existencia del proceso $nullp$, que representa el proceso nulo, y la constante $quantum$, que equivale a 5 ticks.

\begin{axdef}
    nullp : PROCESS
\end{axdef}

\begin{axdef}
    quantum : TICK
\where
    quantum = 5
\end{axdef}

Se define entonces el espacio de estados del planificador y su estado inicial.

\begin{schema}{Dispatcher}
    procQueue : \nat \pinj PROCESS \\
    current : PROCESS \\
    remTicks : TICK
\end{schema}

\begin{schema}{InitDispatcher}
    Dispatcher
\where
    procQueue = \emptyset \\
    current = nullp \\
    remTicks = 0
\end{schema}

Como un proceso no puede estar \textit{en ejecución} y \textit{listo} al mismo tiempo, se plantea el siguiente invarinate de estado:

\begin{schema}{InvDispatcher}
    Dispatcher
\where
    current \notin \ran procQueue \\
    nullp \notin \ran procQueue
\end{schema}

Procedemos con la especificación de las operaciones requeridas. Estas son:
\begin{itemize}
    \item $NewProcess$: para pasar un proceso de estado \textit{nuevo} (o \textit{bloqueado}) a \textit{listo}.
    \item $Dispatch$: modela el funcionamiento del planificador, se encarga de las transiciones entre los estados \textit{listo} y \textit{en ejecución}.
    \item $TerminateProcess$: para pasar un proceso de estado \textit{en ejecución} a \textit{terminado}.
\end{itemize}

\begin{schema}{NewProcessOk}
    \Delta Dispatcher \\
    p? : PROCESS
\where
    procQueue \neq \emptyset \\
    p? \notin \ran procQueue \\
    p? \neq current \\
    p? \neq nullp \\
    procQueue' = procQueue \cup \{max~(\dom procQueue) + 1 \mapsto p?\} \\
    current' = current \\
    remTicks' = remTicks
\end{schema}

\begin{schema}{newProcessOkEmptyQueue}
    \Delta Dispatcher \\
    p? : PROCESS
\where
    procQueue = \emptyset \\
    p? \notin \ran procQueue \\
    p? \neq current \\
    p? \neq nullp \\
    procQueue' = \{1 \mapsto p?\} \\
    current' = current \\
    remTicks' = remTicks
\end{schema}

\begin{schema}{NewProcessError}
    \Xi Dispatcher \\
    p? : PROCESS
\where
    p? \in \ran procQueue \lor p? = current \lor p? = nullp
\end{schema}

\begin{zed}
    NewProcess == NewProcessOk \lor newProcessOkEmptyQueue \lor NewProcessError
\end{zed}

\begin{schema}{Tick}
    \Delta Dispatcher
\where
    remTicks > 0 \\
    current \neq nullp \\
    procQueue' = procQueue \\
    current' = current \\
    remTicks' = remTicks - 1    
\end{schema}

\begin{schema}{Timeout}
    \Delta Dispatcher
\where
    procQueue \neq \emptyset \\
    remTicks = 0 \\
    current \neq nullp \\
    procQueue' = procQueue \cup \{max~(\dom procQueue) + 1 \mapsto current\} \\
    current' = nullp \\
    remTicks' = remTicks 
\end{schema}

\begin{schema}{TimeoutEmptyQueue}
    \Delta Dispatcher
\where
    procQueue = \emptyset \\
    remTicks = 0 \\
    current \neq nullp \\
    procQueue' = \{1 \mapsto current\} \\
    current' = nullp \\
    remTicks' = remTicks 
\end{schema}

\begin{schema}{DispatchProcess}
    \Delta Dispatcher
\where
    current = nullp \\
    procQueue \neq \emptyset \\
    procQueue' = procQueue \setminus \{min~(\dom procQueue) \mapsto procQueue(min~(\dom procQueue))\} \\
    current' = procQueue(min~(\dom procQueue)) \\
    remTicks' = remTicks 
\end{schema}

\begin{schema}{Idle}
    \Xi Dispatcher
\where
    current = nullp \\
    procQueue = \emptyset
\end{schema}

\begin{zed}
    Dispatch == Tick \lor Timeout \lor TimeoutEmptyQueue \lor DispatchProcess \lor Idle
\end{zed}

\begin{schema}{TerminateProcessOk}
    \Delta Dispatcher \\
    p? : PROCESS
\where
    current = p? \\
    procQueue' = procQueue \\
    current' = nullp \\
    remTicks' = remTicks
\end{schema}

\begin{schema}{TerminateProcessError}
    \Xi Dispatcher \\
    p? : PROCESS
\where
    current \neq p?
\end{schema}

\begin{zed}
    TerminateProcess == TerminateProcessOk \lor TerminateProcessError
\end{zed}


\section{Simulaciones en \setlog usando el entorno \textsc{Next}}

Se traduce la especificación a \setlog (en \textbf{planificador.slog}), la cual está correctamente tipada, es decir, pasa el \textbf{type\_check}. A continuación, se presentan dos simulaciones ejecutadas sobre el prototipo \setlog usando el entorno \textsc{Next} y la traza de ejecución de cada una.


\subsection*{1ra simulación}

\begin{verbatim}
[initial]:[invPFun,invIny,invNat,invDispatcher] >>
newProcess(NewProc:[[p1,p2,p3]]) >> 
3:dispatch >>
terminateProc(Proc:p1) >>
8:dispatch.
\end{verbatim}

\begin{verbatim}
Parameters:
Quantum = 5

Execution trace is:
ProcQueue = {},  
Current = process:nullp,  
RemTicks = 0
    ----> newProcess(NewProc:p1)
ProcQueue = {[1,p1]},  
Current = process:nullp,  
RemTicks = 0
    ----> newProcess(NewProc:p2)
ProcQueue = {[1,p1],[2,p2]},  
Current = process:nullp,  
RemTicks = 0
    ----> newProcess(NewProc:p3)
ProcQueue = {[1,p1],[2,p2],[3,p3]},  
Current = process:nullp,  
RemTicks = 0
    ----> dispatch
ProcQueue = {[2,p2],[3,p3]},  
Current = p1,  
RemTicks = 5
    ----> dispatch
ProcQueue = {[2,p2],[3,p3]},  
Current = p1,  
RemTicks = 4
    ----> dispatch
ProcQueue = {[2,p2],[3,p3]},  
Current = p1,  
RemTicks = 3
    ----> terminateProc(Proc:p1)
ProcQueue = {[2,p2],[3,p3]},  
Current = process:nullp,  
RemTicks = 0
    ----> dispatch
ProcQueue = {[3,p3]},  
Current = p2,  
RemTicks = 5
    ----> dispatch
ProcQueue = {[3,p3]},  
Current = p2,  
RemTicks = 4
    ----> dispatch
ProcQueue = {[3,p3]},  
Current = p2,  
RemTicks = 3
    ----> dispatch
ProcQueue = {[3,p3]},  
Current = p2,  
RemTicks = 2
    ----> dispatch
ProcQueue = {[3,p3]},  
Current = p2,  
RemTicks = 1
    ----> dispatch
ProcQueue = {[3,p3]},  
Current = p2,  
RemTicks = 0
    ----> dispatch
ProcQueue = {[3,p3],[4,p2]},  
Current = process:nullp,  
RemTicks = 0
    ----> dispatch
ProcQueue = {[4,p2]},  
Current = p3,  
RemTicks = 5

true
\end{verbatim}

En esta simulación se encolan tres nuevos procesos, \textbf{p1}, \textbf{p2} y \textbf{p3}, en la cola de procesos listos y se inicia la ejecución del primero, la cual es interrumpida por la señal \textbf{terminateProc}. El planificador continúa con la ejecución del segundo proceso hasta que termina el tiempo de ejecución asignado (1 \textbf{quantum}) y es interrumpido por el dispatcher, para luego seguir con la ejecución del proximo proceso en la cola, \textbf{p3}.

Notamos como se verifican todos los invariantes durante la ejecución de la simulación.

\subsection*{2da simulación}

\begin{verbatim}
[initial]:[invPFun,invIny,invNat,invDispatcher] >>
dispatch >>
newProcess(NewProc:[[p1,p1,process:nullp]]) >> 
2:dispatch >>
terminateProc(Proc:p2) >>
5:dispatch.
\end{verbatim}

\begin{verbatim}
Parameters:
Quantum = 5

Execution trace is:
ProcQueue = {},  
Current = process:nullp,  
RemTicks = 0
    ----> dispatch
ProcQueue = {},  
Current = process:nullp,  
RemTicks = 0
    ----> newProcess(NewProc:p1)
ProcQueue = {[1,p1]},  
Current = process:nullp,  
RemTicks = 0
    ----> newProcess(NewProc:p1)
ProcQueue = {[1,p1]},  
Current = process:nullp,  
RemTicks = 0
    ----> newProcess(NewProc:process:nullp)
ProcQueue = {[1,p1]},  
Current = process:nullp,  
RemTicks = 0
    ----> dispatch
ProcQueue = {},  
Current = p1,  
RemTicks = 5
    ----> dispatch
ProcQueue = {},  
Current = p1,  
RemTicks = 4
    ----> terminateProc(Proc:p2)
ProcQueue = {},  
Current = p1,  
RemTicks = 4
    ----> dispatch
ProcQueue = {},  
Current = p1,  
RemTicks = 3
    ----> dispatch
ProcQueue = {},  
Current = p1,  
RemTicks = 2
    ----> dispatch
ProcQueue = {},  
Current = p1,  
RemTicks = 1
    ----> dispatch
ProcQueue = {},  
Current = p1,  
RemTicks = 0
    ----> dispatch
ProcQueue = {[1,p1]},  
Current = process:nullp,  
RemTicks = 0

true
\end{verbatim}

La idea de esta simulación es comprobar el correcto funcionamiento de las operaciones en los casos de error o casos de ejecución borde. Por ejemplo la ejecución de las operaciones \textbf{idle}, \textbf{newProcessError}, \textbf{timeoutEmptyQueue} y \textbf{terminateProcError}.

Notamos como se verifican todos los invariantes durante la ejecución de la simulación.

\section{Generado de Condiciones de Verificación}

Se utiliza el VCG para generar condiciones de verificación sobre la especificación en \setlog, lo cual genera el archivo \textbf{planificador-vc.slog}. Luego el comando \verb|check_vcs_planificador| realiza todas las descargas de prueba automaticamente.

\subsection*{Sobre la interacción con el VCG}

En una primera iteración del comando \verb|check_vcs_planificador|, hubo algunas condiciones de verificación que no fueron descargadas exitosamente. Por lo que fue necesario agregar las siguientes hipótesis en las condiciones de verificación que lo requerían:

\begin{itemize}
    \item hipótesis \verb|invDispatcher(ProcQueue, Current)| en \verb|dispatch_pi_invIny|
    \item hipótesis \verb|invIny(ProcQueue)| en \verb|dispatch_pi_invDispatcher|
\end{itemize}

En ambos casos plantee la negación del enunciado y analicé el contraejemplo que presentaba para saber qué hipótesis era necesario agregar. No utilicé los comandos \verb|vcgce|, \verb|vcacg| y \verb|findh|.

También fue necesario aumentar el timeout para que se logren descargar algunas pruebas, esto lo hice modificando el argumento de \verb|def_to|.

\section{Casos de Prueba con \setlog-TTF}

Luego de que la especificación pase el control de tipos, y sea analizada por el VCG y las condiciones de verificación se hayan consultado y descargado, se generan casos de prubea utilizando \setlog-TTF para todas las operaciones.

\subsection*{Comandos utilizados}

\subsubsection*{Operación \textbf{newProcess}}

\begin{verbatim}
ttf(planificador).
applydnf(newProcess(NewProc)).
writett.
applysp(newProcess_dnf_1,un(ProcQueue, {[Max1, NewProc]}, ProcQueue_)).
prunett.
writett.
gentc.
writetc.
exporttt.
\end{verbatim}

\subsubsection*{Operación \textbf{dispatch}}

\begin{verbatim}
ttf(planificador).
applydnf(dispatch).
writett.
applysp(dispatch_dnf_2,un(ProcQueue, {[Max1, Current]}, ProcQueue_)).
prunett.
writett.
applysp(dispatch_dnf_5,diff(ProcQueue, {[Min, Head]}, ProcQueue_)).
prunett.
writett.
gentc.
writetc.
exporttt.
\end{verbatim}

\subsubsection*{Operación \textbf{terminateProc}}

\begin{verbatim}
ttf(planificador).
applydnf(terminateProc(Proc)).
writett.
gentc.
writett.
writetc.
exporttt.
\end{verbatim}




% Con estos comandos se carga la especificación, se selecciona la operación para la cual generar los casos de prueba y se aplican las tacticas de testing.
% En primer lugar, se aplica \textit{Disjunctive Normal Form (DNF)}, que lleva la operación a su forma normal disyuntiva, ya que es la táctica por defecto que aplica \textsc{Fastest} al ejecutar el comando \verb|genalltt|. 
% Esto particiona la operación de acuerdo a las precondiciones de las suboperaciones que la definen, donde \textit{NewProcess\_DNF\_1} corresponde a \textit{newProcessOk}, \textit{NewProcess\_DNF\_2} corresponde a \textit{newProcessOkEmptyQueue} y las tres restantes corresponden a las tres alternativas de \textit{newProcessError}.
% Luego, se aplican las tacticas de partición estándar (\textit{Standard Partition (SP)}) de $\not\in$ y $\in$, donde resulta útil. Se obtiene el siguiente árbol:

% \begin{minipage}{5cm}
% \dirtree{%
%     .1 $NewProcess\_VIS$.
%     .2 $NewProcess\_DNF\_1$.
%     .3 $NewProcess\_SP\_1$.
%     .3 $NewProcess\_SP\_2$.
%     .2 $NewProcess\_DNF\_2$.
%     .2 $NewProcess\_DNF\_3$.
%     .3 $NewProcess\_SP\_3$.
%     .3 $NewProcess\_SP\_4$.
%     .2 $NewProcess\_DNF\_4$.
%     .2 $NewProcess\_DNF\_5$.
% }
% \end{minipage}

% Finalmente se generan los casos de prueba, obteniendo el siguiente árbol de clases de prueba:

% \begin{minipage}{7cm}
% \dirtree{%
%     .1 $NewProcess\_VIS$.
%     .2 $NewProcess\_DNF\_1$.
%     .3 $NewProcess\_SP\_2$.
%     .4 $NewProcess\_SP\_2\_TCASE$.
%     .2 $NewProcess\_DNF\_2$.
%     .3 $NewProcess\_DNF\_2\_TCASE$.
%     .2 $NewProcess\_DNF\_3$.
%     .3 $NewProcess\_SP\_3$.
%     .4 $NewProcess\_SP\_3\_TCASE$.
%     .3 $NewProcess\_SP\_4$.
%     .4 $NewProcess\_SP\_4\_TCASE$.
%     .2 $NewProcess\_DNF\_4$.
%     .3 $NewProcess\_DNF\_4\_TCASE$.
%     .2 $NewProcess\_DNF\_5$.
%     .3 $NewProcess\_DNF\_5\_TCASE$.
% }
% \end{minipage}

% Notamos que no se generó un caso de prueba para la hoja \verb|NewProcess_SP_1|. Esto es porque es una clase de prueba vacía, ya que contiene tanto $procQueue \neq \{\}$ y $procQueue = \{\}$ como precondiciones.

% \subsection*{Esquemas Z}



\end{document}

