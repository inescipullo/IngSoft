\documentclass{article}
\usepackage[utf8]{inputenc} %codificacion de caracteres que permite tildes
\usepackage{amsfonts}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathrsfs} % Cursive font
\usepackage{fancyhdr}
\usepackage{framed}
% \usepackage{xspace}
\usepackage{dirtree}
% \usepackage{multicol}
\usepackage{z-eves}

\usepackage[T1]{fontenc} % fastest font


\usepackage{float}
\usepackage{graphicx}
\usepackage{subcaption}

\newcommand{\desig}[2]{\item #1 $\approx #2$}
\newenvironment{designations}
  {\begin{leftbar}
    \begin{list}{}{\setlength{\labelsep}{0cm}
                   \setlength{\labelwidth}{0cm}
                   \setlength{\listparindent}{0cm}
                   \setlength{\rightmargin}{\leftmargin}}}
  {\end{list}\end{leftbar}}

\newcommand{\setlog}{$\{log\}$\xspace}


\usepackage{mathtools}
\usepackage{xparse} \DeclarePairedDelimiterX{\Iintv}[1]{\llbracket}{\rrbracket}{\iintvargs{#1}}
\NewDocumentCommand{\iintvargs}{>{\SplitArgument{1}{,}}m}
{\iintvargsaux#1}
\NewDocumentCommand{\iintvargsaux}{mm} {#1\mkern1.5mu,\mkern1.5mu#2}

\makeatletter
\newcommand*{\currentname}{\@currentlabelname}
\makeatother



\addtolength{\textwidth}{0.2cm}
\setlength{\parskip}{8pt}
\setlength{\parindent}{0.5cm}
\linespread{1.5}

\pagestyle{fancy}
\fancyhf{}
\rhead{Cipullo}
\lhead{TP Verificación de Software}
\rfoot{\vspace{1cm} \thepage}

\renewcommand*\contentsname{\LARGE Índice}

\setlength{\skip\footins}{0.5cm}


\begin{document}

\begin{titlepage}
    \hspace{-2.5cm}\includegraphics[scale= 0.48]{header.png}
    \begin{center}
        \vfill
            \noindent\textbf{\Huge Ingeniería de Software}\par
            \vspace{.5cm}
            \noindent\textbf{\Huge Trabajo Práctico Verificación de Software}\par
            \vspace{.5cm}
        \vfill
        % \noindent \textbf{\huge Alumnas:}\par
        \vspace{.5cm}
        \noindent \textbf{\Large Cipullo, Inés}\par
 
        \vfill
        % \large Universidad Nacional de Rosario \par
        \noindent\large 2025
    \end{center}
\end{titlepage}
\ 

\section{Requerimientos}

Se describen los requerimientos de un planificador de procesos a corto plazo, encargado de planificar los procesos que están listos para ejecución, también llamado \textit{dispatcher}. Este planificador implementará el algoritmo de planificaión ``Ronda'' (\textit{Round Robin} en inglés), y este sistema tendrá un único procesador.

Un proceso puede estar en alguno de los siguientes estados: \textit{nuevo}, \textit{listo}, \textit{ejecutando}, \textit{bloqueado}, \textit{terminado}. El dispatcher decide entre los procesos que están listos para ejecutarse y determina a cuál de ellos \textit{activar}, y detiene a aquellos que \textit{exceden su tiempo} de procesador, es decir, se encarga de las transiciones entre los estados \textbf{listo} y \textbf{ejecutando}. 

Siguiendo Round Robin, los procesos listos se almacenan en forma de cola, cada proceso listo se ejecuta por un sólo \textit{quantum} y si un proceso no ha terminado de ejecutarse al final de su período, será interrumpido y puesto al final de la cola de procesos listos.
Se deben tener en cuenta, también, aquellas transiciones que involucran otros estados de procesos pero inciden sobre alguno de los dos estados que se controlan desde el dispatcher. Los procesos que sean agregados a la cola de listos por estas otras transiciones, se ubicarán al final de la misma.


\section{Especificación}
Para empezar, se dan las siguientes designaciones.

\begin{designations}
\desig{$p$ es un proceso}{p \in PROCESS}
\desig{$t$ es un contador de ticks del sistema}{t \in TICK}
\desig{proceso nulo}{nullp}
\desig{cantidad de tiempo durante el cual un proceso tiene permiso para ejecutarse en el procesador antes de ser interrumpido}{quantum}
\desig{cola de procesos listos para ser ejecutados}{procQueue}
\desig{proceso en ejecución}{current}
\desig{contador de ticks restantes de ejecución que le corresponden a $current$}{remTicks}
\end{designations}

Luego, se introducen los tipos que se utilizan en la especificaci\'on. 

\begin{zed}
    [PROCESS]
\also
    TICK == \nat
\end{zed}

Adem\'as, se presentan las siguientes definiciones axiom\'aticas, donde se define la existencia del proceso $nullp$, que representa el proceso nulo, y la constante $quantum$, que equivale a 5 ticks.

\begin{axdef}
    nullp : PROCESS
\end{axdef}

\begin{axdef}
    quantum : TICK
\where
    quantum = 5
\end{axdef}

Se define entonces el espacio de estados del planificador y su estado inicial.

\begin{schema}{Dispatcher}
    procQueue : \seq \langle PROCESS \rangle \\
    current : PROCESS \\
    remTicks : TICK
\end{schema}

\begin{schema}{InitDispatcher}
    Dispatcher
\where
    procQueue = \langle \rangle \\
    current = nullp \\
    remTicks = 0
\end{schema}

Como un proceso no puede estar \textit{en ejecución} y \textit{listo} al mismo tiempo, se plantea el siguiente invarinate de estado:

\begin{schema}{InvDispatcher}
    Dispatcher
\where
    \lnot \langle nullp \rangle \inseq procQueue \\
    \lnot \langle current \rangle \inseq procQueue
\end{schema}

Procedemos con la especificación de las operaciones requeridas. Estas son:
\begin{itemize}
    \item $NewProcess$: para pasar un proceso de estado \textit{nuevo} (o \textit{bloqueado}) a \textit{listo}.
    \item $Dispatch$: modela el funcionamiento del planificador, se encarga de las transiciones entre los estados \textit{listo} y \textit{en ejecución}.
    \item $TerminateProcess$: para pasar un proceso de estado \textit{en ejecución} a \textit{terminado}.
\end{itemize}

\begin{schema}{NewProcessOk}
    \Delta Dispatcher \\
    p? : PROCESS
\where
    p? \notin \ran procQueue \\
    p? \neq current \\
    p? \neq nullp \\
    procQueue' = procQueue \cat \langle p? \rangle \\
    current' = current \\
    remTicks' = remTicks
\end{schema}

\begin{schema}{NewProcessError}
    \Xi Dispatcher \\
    p? : PROCESS
\where
    p? \in \ran procQueue \lor p? = current \lor p? = nullp
\end{schema}

\begin{zed}
    NewProcess == NewProcessOk \lor NewProcessError
\end{zed}

\begin{schema}{Tick}
    \Delta Dispatcher
\where
    remTicks > 0 \\
    current \neq nullp \\
    procQueue' = procQueue \\
    current' = current \\
    remTicks' = remTicks - 1    
\end{schema}

\begin{schema}{Timeout}
    \Delta Dispatcher
\where
    remTicks = 0 \\
    current \neq nullp \\
    procQueue' = procQueue \cat \langle current \rangle \\
    current' = nullp \\
    remTicks' = remTicks 
\end{schema}

\begin{schema}{DispatchProcess}
    \Delta Dispatcher
\where
    current = nullp \\
    procQueue \neq \langle \rangle \\
    procQueue' = tail~procQueue \\
    current' = head~procQueue \\
    remTicks' = remTicks 
\end{schema}

\begin{schema}{Idle}
    \Xi Dispatcher
\where
    current = nullp \\
    procQueue = \langle \rangle
\end{schema}

\begin{zed}
    Dispatch == Tick \lor Timeout \lor DispatchProcess \lor Idle
\end{zed}

\begin{schema}{TerminateProcessOk}
    \Delta Dispatcher \\
    p? : PROCESS
\where
    current = p? \\
    procQueue' = procQueue \\
    current' = nullp \\
    remTicks' = remTicks
\end{schema}

\begin{schema}{TerminateProcessError}
    \Xi Dispatcher \\
    p? : PROCESS
\where
    current \neq p?
\end{schema}

\begin{zed}
    TerminateProcess == TerminateProcessOk \lor TerminateProcessError
\end{zed}


\section{Simulaciones en \textit{\{log\}}}

Se traduce la especificación a \textit{\{log\}} (en \textbf{planificador.slog}). A continuación, se presentan dos simulaciones ejecutadas sobre \textit{\{log\}} y la primera solución de cada una.


\subsection*{1ra simulación}

\begin{verbatim}
    initDispatcher(PQ0, C0, RT0)               & 
    newProcess(PQ0, C0, RT0, p1, PQ1, C1, RT1) & 
    dispatch(PQ1, C1, RT1, PQ2, C2, RT2)       &
    dispatch(PQ2, C2, RT2, PQ3, C3, RT3)       &
    dispatch(PQ3, C3, RT3, PQ4, C4, RT4)       &
    dispatch(PQ4, C4, RT4, PQ5, C5, RT5)       &
    dispatch(PQ5, C5, RT5, PQ6, C6, RT6)       &
    dispatch(PQ6, C6, RT6, PQ7, C7, RT7)       &
    dispatch(PQ7, C7, RT7, PQ8, C8, RT8). 
\end{verbatim}

La idea de esta simulación es encolar un nuevo proceso \textbf{p1} en la cola de procesos listos, luego iniciar su ejecución hasta que termine el tiempo de ejecución asignado (1 \textbf{quantum}) y sea interrumpido por el dispatcher. El resultado es el esperado:

\begin{verbatim}
    PQ0 = {},  
    C0 = nullp,  
    RT0 = 0,  
    PQ1 = {[1,p1]},  
    C1 = nullp,  
    RT1 = 0,  
    PQ2 = {},  
    C2 = p1,  
    RT2 = 5,  
    PQ3 = {},  
    C3 = p1,  
    RT3 = 4,  
    PQ4 = {},  
    C4 = p1,  
    RT4 = 3,  
    PQ5 = {},  
    C5 = p1,  
    RT5 = 2,  
    PQ6 = {},  
    C6 = p1,  
    RT6 = 1,  
    PQ7 = {},  
    C7 = p1,  
    RT7 = 0,  
    PQ8 = {[1,p1]},  
    C8 = nullp,  
    RT8 = 0
\end{verbatim}


\subsection*{2da simulación}

\begin{verbatim}
    initDispatcher(PQ0, C0, RT0)                  & 
    newProcess(PQ0, C0, RT0, p1, PQ1, C1, RT1)    & 
    newProcess(PQ1, C1, RT1, p2, PQ2, C2, RT2)    & 
    dispatch(PQ2, C2, RT2, PQ3, C3, RT3)          &  
    dispatch(PQ3, C3, RT3, PQ4, C4, RT4)          & 
    terminateProc(PQ4, C4, RT4, p1, PQ5, C5, RT5) & 
    dispatch(PQ5, C5, RT5, PQ6, C6, RT6). 
\end{verbatim}

La idea de esta simulación es encolar dos nuevos procesos, \textbf{p1} y \textbf{p2}, en la cola de procesos listos, luego iniciar la ejecución del primero, que ejecute por un tick y que termine su ejecución. Despues se inicia la ejecución del segundo. El resultado es el esperado:

\begin{verbatim}
    PQ0 = {},  
    C0 = nullp,  
    RT0 = 0,  
    PQ1 = {[1,p1]},  
    C1 = nullp,  
    RT1 = 0,  
    PQ2 = {[2,p2],[1,p1]},  
    C2 = nullp,  
    RT2 = 0,  
    PQ3 = {[1,p2]},  
    C3 = p1,  
    RT3 = 5,  
    PQ4 = {[1,p2]},  
    C4 = p1,  
    RT4 = 4,  
    PQ5 = {[1,p2]},  
    C5 = nullp,  
    RT5 = 0,  
    PQ6 = {},  
    C6 = p2,  
    RT6 = 5
\end{verbatim}


\section{Generado de Condiciones de Verificación (WIP)}

Se utiliza el VCG para generar condiciones de verificación sobre la especificación en \textit{\{log\}}, lo cual genera el archivo \textbf{planificador-vc.slog}. Luego el comando \verb|check_vcs_planificador| realiza todas las descargas de prueba automaticamente.

\subsection*{Sobre la interacción con el VCG}

Fue necesario agregar la hipótesis \verb|invSeq(ProcQueue)| en la condición de verificación \verb|dispatch_pi_invDispatcher|. Sin esa hipótesis se presentaba un contraejemplo donde \verb|ProcQueue = {[1,C_],[_N2,C_]}|, lo cual no es válido.


% NUEVO:
% agregar hipótesis \verb|invSeq(ProcQueue)| en newProcess_pi_invPFun
% agregar hipótesis \verb|invSeq(ProcQueue)| en dispatch_pi_invPFun
% agregar hipótesis \verb|invDispatcher(ProcQueue, Current)| en dispatch_pi_invIny
% agregar hipótesis \verb|invIny(ProcQueue)| en dispatch_pi_invDispatcher



También tuve que aumentar el timeout, ya que algunas pruebas resultaron en timeout al principio. Esto fue modificando el parámetro de \verb|def_to|.

\section{Demostración en \textit{Z/EVES}}

Utilizando el asistente de pruebas \textit{Z/EVES}, vamos a demostrar que la operación \verb|TerminateProcess| preserva el invariante de estado \verb|InvDispatcher|.

\begin{theorem}{TerminateProcessInvDispatcher}
    InvDispatcher \land TerminateProcess \implies InvDispatcher'
\end{theorem}

\begin{zproof}[TerminateProcessInvDispatcher]
    invoke TerminateProcess;
    split TerminateProcessOk;
    simplify;
    cases;
    invoke TerminateProcessOk;
    invoke InvDispatcher;
    equality substitute procQueue';
    simplify;
    next;
    invoke TerminateProcessError;
    invoke InvDispatcher;
    invoke \Xi Dispatcher;
    rewrite;
    next;
\end{zproof}

\section{Casos de Prueba con \textsc{Fastest}}


\end{document}

