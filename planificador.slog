% TIPOS
def_type(t_proc_queue, rel(int, process)).

def_type(t_tick, int).

parameters([Quantum]).

% ESTADO
variables([ProcQueue, Current, RemTicks]).

% DEFINICION AXIOMATICA
axiom(quantum).
dec_p_type(quantum(t_tick)).
quantum(Quantum) :- Quantum = 5.

% INVARIANTES
% invariant(invSeq).
% dec_p_type(invSeq(t_proc_queue)).
% invSeq(ProcQueue) :- pfun(ProcQueue) & 
%                      let([Inv], inv(ProcQueue, Inv), pfun(Inv)) &
%                      let([N], size(ProcQueue, N), (N = 0 or dom(ProcQueue, int(1,N)))).

% dec_p_type(n_invSeq(t_proc_queue)).
% n_invSeq(ProcQueue) :- npfun(ProcQueue) & 
%                        neg(let([Inv], inv(ProcQueue, Inv), pfun(Inv))) &
%                        neg(let([N], size(ProcQueue, N), (N = 0 or dom(ProcQueue, int(1,N))))).

invariant(invPFun).
dec_p_type(invPFun(t_proc_queue)).
invPFun(ProcQueue) :- pfun(ProcQueue).

dec_p_type(n_invPFun(t_proc_queue)).
n_invPFun(ProcQueue) :- npfun(ProcQueue).

invariant(invIny).
dec_p_type(invIny(t_proc_queue)).
invIny(ProcQueue) :- let([Inv], inv(ProcQueue, Inv), pfun(Inv)).

dec_p_type(n_invIny(t_proc_queue)).
n_invIny(ProcQueue) :- neg(let([Inv], inv(ProcQueue, Inv), pfun(Inv))).

invariant(invSeq).
dec_p_type(invSeq(t_proc_queue)).
invSeq(ProcQueue) :- let([N], size(ProcQueue, N), (N = 0 or dom(ProcQueue, int(1,N)))).

dec_p_type(n_invSeq(t_proc_queue)).
n_invSeq(ProcQueue) :- neg(let([N], size(ProcQueue, N), (N = 0 or dom(ProcQueue, int(1,N))))).


invariant(invNat).
dec_p_type(invNat(t_tick)).
invNat(RemTicks) :- RemTicks >= 0.

dec_p_type(n_invNat(t_tick)).
n_invNat(RemTicks) :- neg(RemTicks >= 0).

invariant(invDispatcher).
dec_p_type(invDispatcher(t_proc_queue, process)).
invDispatcher(ProcQueue, Current) :- let([Ran], ran(ProcQueue, Ran), Current nin Ran & nullp nin Ran).

dec_p_type(n_invDispatcher(t_proc_queue, process)).
n_invDispatcher(ProcQueue, Current) :- neg(let([Ran], ran(ProcQueue, Ran), Current nin Ran & nullp nin Ran)).

% ESTADO INICIAL
initial(initDispatcher).
dec_p_type(initDispatcher(t_proc_queue, process, t_tick)).
initDispatcher(ProcQueue, Current, RemTicks) :-
    ProcQueue = {} &
    Current = nullp &
    RemTicks = 0.

% OPERACIONES

%%% newProcess %%%
newProcessOk(ProcQueue, Current, RemTicks, NewProc, ProcQueue_, Current_, RemTicks_) :-
    ran(ProcQueue, Ran) & NewProc nin Ran &
    NewProc neq Current &
    NewProc neq nullp &
    size(ProcQueue, N) & N1 is N+1 & dec(N1, int) &
    ProcQueue_ = {[N1, NewProc] / ProcQueue} &
    Current_ = Current &
    RemTicks_ = RemTicks.

newProcessError(ProcQueue, Current, RemTicks, NewProc, ProcQueue_, Current_, RemTicks_) :-
    ((ran(ProcQueue, Ran) & NewProc in Ran) or NewProc = Current or NewProc = nullp) &
    ProcQueue_ = ProcQueue &
    Current_ = Current &
    RemTicks_ = RemTicks.

operation(newProcess).
dec_p_type(newProcess(t_proc_queue, process, t_tick, process, t_proc_queue, process, t_tick)).
newProcess(ProcQueue, Current, RemTicks, NewProc, ProcQueue_, Current_, RemTicks_) :-
    newProcessOk(ProcQueue, Current, RemTicks, NewProc, ProcQueue_, Current_, RemTicks_)
    or
    newProcessError(ProcQueue, Current, RemTicks, NewProc, ProcQueue_, Current_, RemTicks_).

%%% dispatch %%%
tick(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_) :-
    RemTicks > 0 &
    Current neq nullp &
    ProcQueue_ = ProcQueue &
    Current_ = Current &
    RemTicks_ is RemTicks - 1 & dec(RemTicks_, int).

timeout(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_) :-
    RemTicks = 0 &
    Current neq nullp &
    size(ProcQueue, N) & N1 is N+1 & dec(N1, int) &
    ProcQueue_ = {[N1, Current] / ProcQueue} &
    Current_ = nullp &
    RemTicks_ = 0.

idle(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_) :-
    Current = nullp &
    ProcQueue = {} &
    ProcQueue_ = ProcQueue &
    Current_ = Current &
    RemTicks_ = RemTicks.

% Funcion auxiliar
% shift_indexes/2: Shifts indexes by -1
shift_indexes({}, N, {}).
shift_indexes(Tail, Next, Result) :-
    Tail = {[Next,V] / Rest} &
    Next1 is Next - 1 & dec(Next1, int) &
    Next2 is Next + 1 & dec(Next2, int) &
    shift_indexes(Rest, Next2, RestShifted) &
    Result = {[Next1,V] / RestShifted}.

dispatchProc(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_) :-
    Current = nullp &
    ProcQueue neq {} &
    RemTicks = 0 &
    ProcQueue = {[1,Head] / Tail} & [1,Head] nin Tail &
    shift_indexes(Tail, ProcQueue_) &
    Current_ = Head &
    quantum(RemTicks_).

operation(dispatch).
dec_p_type(dispatch(t_proc_queue, process, t_tick, t_proc_queue, process, t_tick)).
dispatch(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_) :-
    tick(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_)
    or
    timeout(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_)
    or
    idle(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_)
    or
    dispatchProc(ProcQueue, Current, RemTicks, ProcQueue_, Current_, RemTicks_).

%%% terminateProc %%%
terminateProcOk(ProcQueue, Current, RemTicks, Proc, ProcQueue_, Current_, RemTicks_) :-
    Current = Proc &
    RemTicks neq 0 &
    ProcQueue_ = ProcQueue &
    Current_ = nullp &
    RemTicks_ = 0.

terminateProcError(ProcQueue, Current, RemTicks, Proc, ProcQueue_, Current_, RemTicks_) :-
    Current neq Proc & 
    RemTicks >= 0 &
    ProcQueue_ = ProcQueue &
    Current_ = Current &
    RemTicks_ = RemTicks.

operation(terminateProc).
dec_p_type(terminateProc(t_proc_queue, process, t_tick, process, t_proc_queue, process, t_tick)).
terminateProc(ProcQueue, Current, RemTicks, Proc, ProcQueue_, Current_, RemTicks_) :-
    terminateProcOk(ProcQueue, Current, RemTicks, Proc, ProcQueue_, Current_, RemTicks_)
    or
    terminateProcError(ProcQueue, Current, RemTicks, Proc, ProcQueue_, Current_, RemTicks_).
